- STATICKE I DINAMICKE SQL NAREDBE 

- SQL NAREDBE:
  1.  INTERAKTIVNO
  2.  APLIKATIVNO - UMETNEMO SQL NAREDBE U VISI PROGRAMSKI JEZIK
        - MOGU DA SE KOMBINUJU SA NAREDBAMA VISEG PROGRAMSKOG JEZIKA
        - TAKVE NAREDBE MOGU DA BUDU :
          1.  STATICKE - CELA NAREDBA JE POZNATA I VIDIMO KAKAV ODGOVOR CEMO DOBITI OD BAZE
                - MOGU SE ANALIZIRATI I PRIPREMITI U FAZI PREDPROCESIRANJA
          2.  DINAMICKE - NISU U POTPUNOSTI POZNATE U FAZI PISANJA PROGRAMA ; 
                - POZNAT JE SAMO DEO SQL NAREDBE 
                - OSTATAK JE POZNAT U TOKU IZVRSAVANJA PROGRAMA 
                - U FAZI PREDPROCESIRANJA NE MOGU DA SE ZNAJU NAZIVI KOLONA, TABELA 
                  I NE MOGU SE IZVRSITI NAREDBA PRIPREMANJA 
  
- DA LI JE NEZAVISAN OD SUBP
  - SQC STATICKI/DINAMICKI    NIJE  
  - JDBC, ODBC DINAMICKI      JESTE
  - CLI DINAMICKI             NE

- JDBC

- ODBC STANDARD = OPEN DATABASE CONECTIVITY
  - MOZE DA SE PISE PROGRAM NEZAVISNO OD TOGA KOJA BAZA SE KORISTI
    I SA ODGOVARAJUCIM DRAJVEROM MOZE DA SE PROMENI KOJI JE TO KONKRETAN 
    SISTEM 

- CLI = DIREKTNI POZIVI ODGOVARAJUCIH DB2 FUNKCIJA 
  - NEMAMO STATICKE SQL NAREDBE 
  - NE MOZEMO DA ISKORISTIMO NJIHOVE PREDNOSTI
  - IMAMO ZAPAMCENE PROCEDURE 
    - MOZE DA BUDE DEO KOJI SE IZVRSAVA NA SERVERU, A DRUGI DEO APP KOJI SE IZVRSAVA NA KLIJENTU

---------------------------------------------------------------------------------------------------------

    ---  APLIKATIVNI SQL = SQC ---

- MATICNI JEZIK (HOST LANGUAGE) - C/JAVA/C++
  - DA POZIVAMO SQL IZ NEKOG VISEG PROGRAMSKOG JEZIKA 

- KAKO DA RAZMENJUJEMO PODATEK IZMEDJU OVA DVA JEZIKA?

- KOJI SU ODGOVARAJUCI TIPOVI PODATAKA U C KOJI MOGU DA PRIHVATE PORMENLJVE IZ SQL 
  - U SQL STAVLJAMO : ISPRED HOST PORMENLJIVIH - DA PO TIPU ODVOVARAJU ONOM TIPU U BAZI 

- SQLCA = PROSTOR ZA KOMUNIKACIJU - MORA SE UVEK UKLJUCITI! 
  - EXEC SQL ; = SA OVOM NAREDBOM SE VRSI KOMUNIKACIJA SA BAZOM 
  - EXEC SQL INCLUDE SQLCA; -- OBAVEZNOO!!!! 
    - ZA OVU NAREDBU SE POBRINJAVA SQL PREDPROCESOR 
  
  - SQLCODE == 0 SVE JE PROSLO USPESNO 
    - NAKON SVAKE SQL NAREDBE, SQLCODE JE POTENCIJALNO PROMENILA SVOJU VREDNOST
    - == 100 SVE JE PROCITANO, NEMA VISE REDOVA ZA CITANJE
    - < 0 TADA ZNAMO DA JE DOSLO DO NEKE GRESKE 
  
- EXEC SQL WENEVER GOTO ... = MOZE DA PROIZVEDE TZV. SPAGETI KOD KOJI JE JAKO NECITLJIV I NERAZUMLJIV 

- FAZE PREVODJENJA:
  1. PREPROCESIRANJE DB2PREP - KREIRA SE PAKET 
  2. HOST LANGUAGE COMPILER 
  3. DOBIJANJE IZVRSIVOG PROGRAMA KOJI SE NA KRAJU MOZE POKRETATI BEZBROJ PUTA 

- HOST PROMENLJIVE NAM PREDSTAVLJAJU SPONU IZMEDJU SQL I HOST JEZIKA 
  - PROMENJLJIVE U HOST JEZIKU 
  - NJIHOVA DEKLARACIJA SE VRSI U POSEBNOJ SEKCIJI:
      EXEC SQL BEGIN DELCARE SECTION;
      -- DEFINISANJE HOST PROMENJIVIH
      EXEC SQL END DECLARE SECTION;
  - MORAMO DA VODIMO RACUNA O TOME KAKO SU PODACI REPREZENTOVATI U BAZI 
  
  +--------------------+-----------------------+
  |       SQL          |            C          |
  |--------------------------------------------|
  |     SMALLINT       |        short          |
  |--------------------------------------------|
  |     INTEGER        |        long           |
  |--------------------------------------------|
  |     DOUBLE         |        double         |
  |--------------------------------------------|
  |     CHAR           |        char           |
  |--------------------------------------------|
  |     CHAR(n)        |        char[n+1]      |
  |--------------------------------------------|
  |     VARCHAR(n)     |        char[n+1]      |
  |--------------------------------------------|
  |     DATE           |        char[11]       |
  |--------------------------------------------|
  |     TIME           |        char[9]        |
  +--------------------+-----------------------+


  - SELECT NAREDBA - VRACA ODREDJENE PODATKE KOJE TREBAMO DA SMESTIMO
    - KOLIKO REDOVA DOBIJAMO?
      - AKO DOBIJAMO JEDAN RED KORISTIMO *SELECT-INTO*
        - DODATNO DEKLARISEMO INDIKATORSKU PROMENLJIVU, KOJA CUVA INFORMACIJU O TOME DA
          LI JE PODATAK BIO ILI NIJE BIO NULL U BAZI 
        - NA OSNOVU PRIMARNOG KLJUCA MOZEMO DA OBEZBEDIMO DA CE DA VRATI TACNO JEDAN RED 

      - AKO DOBIJAMO VISE OD JEDNOG REDA KAO REZULTAT, TADA KORISTIMO KURSORE.
        1. DEKLARACIJA KURSORA 

            EXEC SQL DECLARE <naziv_kursora> CURSOR FOR <upit>;

        2. OTVARANJE KURSORA 
          - MOZE DA SE OTVARA VISE PUTA UKOLIKO IMAMO PARAMTERIZOVANE PROMENLJIVE???

            EXEC SQL OPEN <naziv_kursora>;
        
        3. ITERIRANJE KROZ KURSOR 
          - TE PODATKE IZ REDA MORAMO DA SMESTIMO U HOST PROMENLJIVE KOJE CE DA IH PRIHVATE 
          - KRAJ JE KADA SQLCODE == 100, TADA NEMAMO VISE REZULTATA ZA CITANJE

            EXEC SQL FETCH <naziv_kursora> INTO <lista_host_promenljivih>;
        
        4. ZATVARANJE KURSORA 
          - MORAMO DA GA ZATVORIMO, JER ZELIMO MOZDA OPET PONOVO DA GA OTVORIMO

            EXEC SQL CLOSE <naziv_kursora>;

      - MOZE DA SE NAVEDE DA LI SE KURSOR KORISTI ZA :
        1.  CITANJE    = FOR READ ONLY 
        2.  AZURIRANJE = FOR UPDATE OF <LISTA_ATTRIBUTA>

            EXEC SQL
            UPDATE DA.PREDMET 
            SET ESPB = ESPB + 1
            WHERE CURRENT OF <naziv_kursora>

            - MORA DA SADRZI SAMO JEDNU TABELU, NE SME DA IMA GROUP BY I HAVING,
              I ORDER BY JER MENJAMO REDOSLED 
              UNION, INTERSECT NE SME, OSIM UNION ALL 
              DISTINCT NE SME 
              NIKAKVE AGREGATNE FUNKCIJE 

              OGRANICENJA MORAJU DA SE NAVEDU U WHERE LINIJI : TU PRESKACEMO NEKE REDOVE KOJI NE ZADOVOLJAVAJU USLOVE 


